package xdptun

import (
	"context"
	"math/rand"
	"net"
	"net/netip"
	"testing"

	"github.com/Crosse/xdp"
	"github.com/stretchr/testify/require"
	"github.com/vishvananda/netlink"
	"golang.org/x/sys/unix"

	"github.com/getlantern/lantern-cloud/cmd/pfe/arp"
	clog "github.com/getlantern/lantern-cloud/cmd/pfe/conditional_log"
)

func init() {
	rand.Seed(1)
	clog.SetLogLevel(clog.LevelInfo)
}

func TestIPv4TunnelRewrite(t *testing.T) {
	frame := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x16, 0x3e, 0x00, 0x91, 0xe4, // destination MAC
		0xee, 0x11, 0x22, 0x33, 0x44, 0x55, // source MAC
		0x08, 0x00, // EtherType
		0x45,       // IPv4, IHL = 5
		0x14,       // DSCP, ECN
		0x00, 0x40, // total length
		0xfc, 0x83, // identification
		0x40, 0x00, // flags (DF set), fragment offset
		0x2e,       // time to live
		0x06,       // protocol (TCP)
		0x1c, 0x78, // header checksum
		0xae, 0x35, 0x5f, 0x99, // source address
		0x0a, 0x0a, 0x1b, 0xd0, // destination address
		0xa1, 0x38, // source port
		0x1f, 0x90, // destination port
		0x1a, 0xa8, 0x85, 0xd4, // TCP sequence number
		0x00, 0x00, 0x00, 0x00, // acknowledgement number
		0xb0, 0x02, // TCP segment length, flags
		0x40, 0x00, // window
		0x42, 0x28, // TCP checksum
		0x00, 0x00, // urgent pointer
		0x02, 0x04, 0x05, 0xb4, 0x01, 0x01, 0x04, 0x02, // tcp options
		0x01, 0x03, 0x03, 0x06, 0x01, 0x01, 0x08, 0x0a, // tcp options
		0x4d, 0x83, 0xd1, 0x61, 0x00, 0x00, 0x00, 0x00, // tcp options
	}

	// rewrite dest ip 10.10.27.208 -> 8.209.116.189, encap -> 136.144.49.65
	ipMap := map[netip.Addr]AssociatedIPs{
		netip.MustParseAddr("10.10.27.208"): {
			EIP:          netip.MustParseAddr("8.209.116.189"),
			TunnelSource: netip.MustParseAddr("10.10.27.208"),
			TunnelDest:   netip.MustParseAddr("136.144.49.65"),
			TunnelPort:   5555,
		},
	}

	descOrig := xdp.Desc{
		Addr: 8476,
		Len:  uint32(len(frame) - fouHeadroom),
	}

	tunnel := Tunnel{
		Headroom:   fouHeadroom,
		sourcePort: 62103,
		link: &netlink.Dummy{
			LinkAttrs: netlink.LinkAttrs{
				HardwareAddr: []byte{0x00, 0x16, 0x3e, 0x00, 0x91, 0xe4},
			},
		},
		linkMTU:  1500,
		arpCache: &arp.Cache{},
		ctx:      context.Background(),
	}

	// adding this entry will verify that MAC address lookups are working and we're not just
	// reversing the MAC adresses
	neigh := netlink.Neigh{}
	neigh.LinkIndex = 0
	neigh.Family = unix.AF_INET
	neigh.State = unix.NUD_REACHABLE
	neigh.Type = netlink.NDA_DST
	neigh.IP = net.ParseIP("136.144.49.65")
	neigh.HardwareAddr = net.HardwareAddr{0xee, 0xff, 0xff, 0xff, 0xff, 0xff}
	tunnel.arpCache.Update(neigh)

	var shouldTx bool
	var err error
	desc := descOrig
	require.NotPanics(t, func() { shouldTx, err = tunnel.handleIP(&desc, frame, &ipMap) })
	require.NoError(t, err)
	require.True(t, shouldTx, "packet should not get dropped")

	expected := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // unused headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // unused headroom
		0x00, 0x00, 0x00, 0x00, // unused headroom
		0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x16,
		0x3e, 0x00, 0x91, 0xe4, 0x08, 0x00, 0x45, 0x00,
		0x00, 0x5c, 0xfd, 0x52, 0x00, 0x00, 0x40, 0x11,
		0x9d, 0x93, 0x0a, 0x0a, 0x1b, 0xd0, 0x88, 0x90,
		0x31, 0x41, 0xf2, 0x97, 0x15, 0xb3, 0x00, 0x48,
		0xa2, 0xf7, 0x45, 0x14, 0x00, 0x40, 0xfc, 0x83,
		0x40, 0x00, 0x2e, 0x06, 0xc4, 0xc3, 0xae, 0x35,
		0x5f, 0x99, 0x08, 0xd1, 0x74, 0xbd, 0xa1, 0x38,
		0x1f, 0x90, 0x1a, 0xa8, 0x85, 0xd4, 0x00, 0x00,
		0x00, 0x00, 0xb0, 0x02, 0x40, 0x00, 0xea, 0x73,
		0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x01,
		0x04, 0x02, 0x01, 0x03, 0x03, 0x06, 0x01, 0x01,
		0x08, 0x0a, 0x4d, 0x83, 0xd1, 0x61, 0x00, 0x00,
		0x00, 0x00,
	}

	hdrLen := ipv4HeaderLen + fouHeaderLen
	require.EqualValues(t, descOrig.Len+uint32(hdrLen), desc.Len, "desc.Len is incorrect")
	require.EqualValues(t, descOrig.Addr-uint64(hdrLen), desc.Addr, "desc.Addr is incorrect")
	require.Equal(t, expected, frame)
}

func TestIPv6TunnelRewrite(t *testing.T) {
	testFrame := smallTcpPacket()
	frame := append([]byte{}, testFrame.OriginalFrame...)

	descOrig := xdp.Desc{
		Addr: 33072,
		Len:  uint32(len(frame) - fouHeadroom),
	}

	tunnel := Tunnel{
		Headroom:   fouHeadroom,
		sourcePort: testFrame.TunnelSourcePort,
		link: &netlink.Dummy{
			LinkAttrs: netlink.LinkAttrs{
				HardwareAddr: testFrame.OriginalFrame[fouHeadroom : fouHeadroom+6],
			},
		},
		linkMTU:  1500,
		arpCache: &arp.Cache{},
		ctx:      context.Background(),
	}

	neigh := netlink.Neigh{}
	neigh.LinkIndex = 0
	neigh.Family = unix.AF_INET
	neigh.State = unix.NUD_REACHABLE
	neigh.Type = netlink.NDA_DST
	for _, v := range testFrame.IPMap {
		neigh.IP = v.TunnelDest.AsSlice()
	}
	neigh.HardwareAddr = append([]byte{}, testFrame.TunneledFrame[:6]...)
	tunnel.arpCache.Update(neigh)

	desc := descOrig
	shouldTx, err := tunnel.handleIP(&desc, frame, &testFrame.IPMap)
	require.NoError(t, err)
	require.True(t, shouldTx)

	hdrLen := ipv6HeaderLen + fouHeaderLen
	require.EqualValues(t, descOrig.Len+uint32(hdrLen), desc.Len, "desc.Len is incorrect")
	require.EqualValues(t, descOrig.Addr-uint64(hdrLen), desc.Addr, "desc.Addr is incorrect")
	require.Equal(t, testFrame.TunneledFrame, frame)
}

func TestMTUHandling(t *testing.T) {
	frame := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x16, 0x3E, 0x01, 0x7F, 0xA3, 0xEE, 0xFF, // Ethernet header
		0xFF, 0xFF, 0xFF, 0xFF, 0x08, 0x00,
		0x45, 0x14, 0x00, 0x40, 0x46, 0x91, 0x00, 0xAC, // IPv4 header
		0x31, 0x06, 0xCF, 0x8C, 0x97, 0xEF, 0x6A, 0x3A,
		0x0A, 0x0A, 0x06, 0x64,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
	}

	ipMap := map[netip.Addr]AssociatedIPs{
		netip.MustParseAddr("10.10.6.100"): {
			EIP:          netip.MustParseAddr("8.209.103.224"),
			TunnelSource: netip.MustParseAddr("240b:4005:18:ad01:5b8f:8bbc:c268:4be0"),
			TunnelDest:   netip.MustParseAddr("2606:f240:f00:46c4:0:16:3e01:7fa3"),
			TunnelPort:   5555,
		},
	}

	desc := xdp.Desc{
		Addr: 8476,
		Len:  0, // we set this in our tests below
	}

	tunnel := Tunnel{
		Headroom:   fouHeadroom,
		sourcePort: 62103,
		link: &netlink.Dummy{
			LinkAttrs: netlink.LinkAttrs{
				HardwareAddr: []byte{0x00, 0x16, 0x3e, 0x01, 0x7f, 0xa3},
			},
		},
		linkMTU:  100 + fouHeadroom,
		arpCache: &arp.Cache{},
		ctx:      context.Background(),
	}

	tests := map[string]struct {
		packetLen int
		shouldTx  bool
	}{
		"larger than mtu":  {packetLen: 108, shouldTx: false},
		"mtu+1":            {packetLen: 101, shouldTx: false},
		"equal to mtu":     {packetLen: 100, shouldTx: true},
		"mtu-1":            {packetLen: 99, shouldTx: true},
		"smaller than mtu": {packetLen: 90, shouldTx: true},
	}

	droppedJumbograms := 0
	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			desc.Len = uint32(tc.packetLen + 14 + fouHeadroom)
			testFrame := make([]byte, desc.Len)
			copy(testFrame, frame[:desc.Len])

			var shouldTx bool
			var err error
			require.NotPanics(t, func() { shouldTx, err = tunnel.handleIP(&desc, testFrame, &ipMap) })
			require.NoError(t, err)
			require.Equal(t, tc.shouldTx, shouldTx)
			if !tc.shouldTx {
				droppedJumbograms++
				require.EqualValues(t, droppedJumbograms, tunnel.stats.DroppedJumbograms)
			}
		})
	}
}

func BenchmarkIPv4TunnelRewrite(b *testing.B) {
	frame := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // headroom
		0x00, 0x16, 0x3e, 0x00, 0x91, 0xe4, // destination MAC
		0xee, 0x11, 0x22, 0x33, 0x44, 0x55, // source MAC
		0x08, 0x00, // EtherType
		0x45,       // IPv4, IHL = 5
		0x14,       // DSCP, ECN
		0x00, 0x40, // total length
		0xfc, 0x83, // identification
		0x40, 0x00, // flags (DF set), fragment offset
		0x2e,       // time to live
		0x06,       // protocol (TCP)
		0x1c, 0x78, // header checksum
		0xae, 0x35, 0x5f, 0x99, // source address
		0x0a, 0x0a, 0x1b, 0xd0, // destination address
		0xa1, 0x38, // source port
		0x1f, 0x90, // destination port
		0x1a, 0xa8, 0x85, 0xd4, // TCP sequence number
		0x00, 0x00, 0x00, 0x00, // acknowledgement number
		0xb0, 0x02, // TCP segment length, flags
		0x40, 0x00, // window
		0x42, 0x28, // TCP checksum
		0x00, 0x00, // urgent pointer
		0x02, 0x04, 0x05, 0xb4, 0x01, 0x01, 0x04, 0x02, // tcp options
		0x01, 0x03, 0x03, 0x06, 0x01, 0x01, 0x08, 0x0a, // tcp options
		0x4d, 0x83, 0xd1, 0x61, 0x00, 0x00, 0x00, 0x00, // tcp options

		// payload
		0x23, 0x20, 0x57, 0x65,
		0x6c, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74,
		0x68, 0x65, 0x20, 0x4c, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x6e,
		0x65, 0x74, 0x0a, 0x0a, 0x54, 0x68, 0x69, 0x73, 0x20, 0x72,
		0x65, 0x70, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
		0x6e, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6f, 0x6f, 0x66,
		0x2d, 0x6f, 0x66, 0x2d, 0x63, 0x6f, 0x6e, 0x63, 0x65, 0x70,
		0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x6e, 0x65,
		0x77, 0x20, 0x77, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x64,
		0x65, 0x70, 0x6c, 0x6f, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x20,
		0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x20, 0x70, 0x72, 0x6f,
		0x78, 0x69, 0x65, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x77,
		0x65, 0x6c, 0x6c, 0x20, 0x61, 0x73, 0x20, 0x69, 0x6e, 0x74,
		0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x61, 0x6e, 0x64, 0x20,
		0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x73,
		0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2e, 0x0a, 0x0a,
		0x23, 0x23, 0x20, 0x47, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67,
		0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0a, 0x0a,
		0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2c,
		0x20, 0x74, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x6f,
		0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x50, 0x49, 0x2c,
		0x20, 0x79, 0x6f, 0x75, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x20,
		0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77,
		0x69, 0x6e, 0x67, 0x20, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x69,
		0x65, 0x73, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62,
		0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72,
		0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x61, 0x6e, 0x64, 0x20,
		0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x64,
		0x3a, 0x0a, 0x0a, 0x20, 0x2d, 0x20, 0x60, 0x67, 0x6f, 0x60,
		0x0a, 0x20, 0x2d, 0x20, 0x60, 0x64, 0x6f, 0x63, 0x6b, 0x65,
		0x72, 0x60, 0x0a, 0x20, 0x2d, 0x20, 0x60, 0x67, 0x63, 0x6c,
		0x6f, 0x75, 0x64, 0x60, 0x20, 0x28, 0x5b, 0x69, 0x6e, 0x73,
		0x74, 0x61, 0x6c, 0x6c, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x5d,
		0x28, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x63,
		0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
		0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x73, 0x64, 0x6b, 0x2f,
		0x64, 0x6f, 0x63, 0x73, 0x2f, 0x69, 0x6e, 0x73, 0x74, 0x61,
		0x6c, 0x6c, 0x29, 0x29, 0x0a, 0x0a, 0x49, 0x6e, 0x20, 0x6f,
		0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x75,
		0x69, 0x6c, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6c, 0x61,
		0x75, 0x6e, 0x63, 0x68, 0x20, 0x70, 0x72, 0x6f, 0x78, 0x69,
		0x65, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x63, 0x6f, 0x6e, 0x66,
		0x69, 0x67, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x72,
		0x61, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65,
		0x2c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x61, 0x6c, 0x73, 0x6f,
		0x20, 0x6e, 0x65, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20,
		0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x3a,
		0x0a, 0x0a, 0x20, 0x2d, 0x20, 0x60, 0x74, 0x65, 0x72, 0x72,
		0x61, 0x66, 0x6f, 0x72, 0x6d, 0x60, 0x0a, 0x20, 0x2d, 0x20,
		0x60, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x60, 0x0a, 0x20, 0x2d,
		0x20, 0x60, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x60, 0x0a,
		0x0a, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x6c, 0x79, 0x2c, 0x20,
		0x79, 0x6f, 0x75, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x20, 0x74,
		0x6f, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x20,
		0x74, 0x68, 0x65, 0x20, 0x5b, 0x60, 0x74, 0x61, 0x69, 0x6c,
		0x73, 0x63, 0x61, 0x6c, 0x65, 0x60, 0x20, 0x56, 0x50, 0x4e,
		0x5d, 0x28, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f,
		0x74, 0x61, 0x69, 0x6c, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
		0x63, 0x6f, 0x6d, 0x2f, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f,
		0x61, 0x64, 0x29, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6c,
		0x6f, 0x67, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x69, 0x61, 0x20,
		0x79, 0x6f, 0x75, 0x72, 0x20, 0x67, 0x65, 0x74, 0x6c, 0x61,
		0x6e, 0x74, 0x65, 0x72, 0x6e, 0x2e, 0x6f, 0x72, 0x67, 0x20,
		0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x61, 0x63, 0x63,
		0x6f, 0x75, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x2a, 0x2a, 0x54,
		0x6f, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x20,
		0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x6e, 0x67,
		0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x20, 0x67, 0x6f,
		0x20, 0x61, 0x6e, 0x64, 0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65,
		0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x48, 0x6f, 0x6d,
		0x65, 0x62, 0x72, 0x65, 0x77, 0x2a, 0x2a, 0x2c, 0x20, 0x72,
		0x75, 0x6e, 0x20, 0x60, 0x62, 0x72, 0x65, 0x77, 0x20, 0x62,
		0x75, 0x6e, 0x64, 0x6c, 0x65, 0x60, 0x20, 0x69, 0x6e, 0x20,
		0x74, 0x68, 0x65, 0x20, 0x74, 0x6f, 0x70, 0x2d, 0x6c, 0x65,
		0x76, 0x65, 0x6c, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
		0x6f, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x23, 0x23, 0x20, 0x57,
		0x68, 0x61, 0x74, 0x27, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74,
		0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x73, 0x69,
		0x74, 0x6f, 0x72, 0x79, 0x3f, 0x0a, 0x0a, 0x4d, 0x6f, 0x73,
		0x74, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72,
		0x69, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x67, 0x6f,
		0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x73, 0x3a, 0x0a,
		0x0a, 0x20, 0x2d, 0x20, 0x60, 0x61, 0x75, 0x74, 0x68, 0x60,
		0x3a, 0x20, 0x68, 0x65, 0x6c, 0x70, 0x65, 0x72, 0x73, 0x20,
		0x66, 0x6f, 0x72, 0x20, 0x66, 0x65, 0x74, 0x63, 0x68, 0x69,
		0x6e, 0x67, 0x20, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
		0x69, 0x61, 0x6c, 0x73, 0x0a, 0x20, 0x2d, 0x20, 0x60, 0x63,
		0x6d, 0x64, 0x60, 0x3a, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x20,
		0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x67, 0x6f,
		0x20, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x69, 0x65, 0x73, 0x0a,
		0x20, 0x2d, 0x20, 0x60, 0x64, 0x62, 0x60, 0x3a, 0x20, 0x61,
		0x20, 0x77, 0x72, 0x61, 0x70, 0x70, 0x65, 0x72, 0x20, 0x61,
		0x72, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x60, 0x73, 0x71, 0x6c,
		0x78, 0x2e, 0x44, 0x42, 0x60, 0x0a, 0x20, 0x2d, 0x20, 0x60,
		0x65, 0x6e, 0x76, 0x60, 0x3a, 0x20, 0x61, 0x20, 0x68, 0x65,
		0x6c, 0x70, 0x65, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x64,
		0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x69, 0x6e, 0x67,
		0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x74, 0x69,
		0x6d, 0x65, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e,
		0x6d, 0x65, 0x6e, 0x74, 0x0a, 0x20, 0x2d, 0x20, 0x60, 0x69,
		0x6e, 0x76, 0x65, 0x6e, 0x74, 0x6f, 0x72, 0x79, 0x60, 0x3a,
		0x20, 0x63, 0x6f, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20,
		0x6d, 0x61, 0x6e, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x20, 0x70,
		0x72, 0x6f, 0x78, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64,
		0x20, 0x49, 0x50, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68,
		0x65, 0x20, 0x76, 0x61, 0x72, 0x69, 0x6f, 0x75, 0x73, 0x20,
		0x63, 0x6c, 0x6f, 0x75, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x76,
		0x69, 0x64, 0x65, 0x72, 0x73, 0x0a, 0x20, 0x2d, 0x20, 0x60,
		0x6c, 0x6f, 0x67, 0x60, 0x3a, 0x20, 0x61, 0x20, 0x73, 0x6d,
		0x61, 0x6c, 0x6c, 0x20, 0x6c, 0x6f, 0x67, 0x67, 0x69, 0x6e,
		0x67, 0x20, 0x6c, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x20,
		0x66, 0x6f, 0x72, 0x20, 0x6c, 0x6f, 0x67, 0x67, 0x69, 0x6e,
		0x67, 0x20, 0x74, 0x6f, 0x20, 0x47, 0x6f, 0x6f, 0x67, 0x6c,
		0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6c, 0x79,
		0x0a, 0x20, 0x2d, 0x20, 0x60, 0x72, 0x6f, 0x75, 0x74, 0x65,
		0x72, 0x60, 0x3a, 0x20, 0x61, 0x20, 0x74, 0x79, 0x70, 0x65,
		0x2d, 0x73, 0x61, 0x66, 0x65, 0x20, 0x68, 0x74, 0x74, 0x70,
		0x20, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x20, 0x66, 0x6f,
		0x72, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x61, 0x6e,
		0x64, 0x20, 0x6a, 0x73, 0x6f, 0x6e, 0x0a, 0x20, 0x2d, 0x20,
		0x60, 0x74, 0x65, 0x73, 0x74, 0x64, 0x62, 0x60, 0x3a, 0x20,
		0x61, 0x20, 0x75, 0x74, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20,
		0x66, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x75, 0x73, 0x69, 0x6e,
		0x67, 0x20, 0x70, 0x6f, 0x73, 0x74, 0x67, 0x72, 0x65, 0x73,
		0x20, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x73,
		0x20, 0x69, 0x6e, 0x20, 0x74, 0x65, 0x73, 0x74, 0x73, 0x0a,
		0x20, 0x2d, 0x20, 0x60, 0x76, 0x65, 0x6e, 0x64, 0x6f, 0x72,
		0x60, 0x3a, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x66, 0x20,
		0x6f, 0x75, 0x72, 0x20, 0x67, 0x6f, 0x20, 0x64, 0x65, 0x70,
		0x65, 0x6e, 0x64, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73, 0x0a,
		0x0a, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x74, 0x20,
		0x70, 0x65, 0x72, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x74,
		0x6f, 0x20, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x73, 0x74, 0x72,
		0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x3a, 0x0a, 0x0a, 0x20,
		0x2d, 0x20, 0x60, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x60,
		0x3a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73,
		0x20, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x66, 0x69, 0x6c,
		0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x76, 0x61, 0x72,
		0x69, 0x6f, 0x75, 0x73, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69,
		0x63, 0x65, 0x73, 0x0a, 0x20, 0x2d, 0x20, 0x60, 0x62, 0x69,
		0x6e, 0x60, 0x3a, 0x20, 0x73, 0x68,
	}

	// rewrite dest ip 10.10.27.208 -> 8.209.116.189, encap -> 136.144.49.65
	ipMap := map[netip.Addr]AssociatedIPs{
		netip.MustParseAddr("10.10.27.208"): {
			EIP:          netip.MustParseAddr("8.209.116.189"),
			TunnelSource: netip.MustParseAddr("10.10.27.208"),
			TunnelDest:   netip.MustParseAddr("136.144.49.65"),
			TunnelPort:   5555,
		},
	}

	tunnel := Tunnel{
		Headroom:   fouHeadroom,
		sourcePort: 62103,
		link: &netlink.Dummy{
			LinkAttrs: netlink.LinkAttrs{
				HardwareAddr: []byte{0x00, 0x16, 0x3e, 0x00, 0x91, 0xe4},
			},
		},
		linkMTU:  1500,
		arpCache: &arp.Cache{},
		ctx:      context.Background(),
	}

	// adding this entry will verify that MAC address lookups are working and we're not just
	// reversing the MAC adresses
	neigh := netlink.Neigh{}
	neigh.LinkIndex = 0
	neigh.Family = unix.AF_INET
	neigh.State = unix.NUD_REACHABLE
	neigh.Type = netlink.NDA_DST
	neigh.IP = net.ParseIP("136.144.49.65")
	neigh.HardwareAddr = net.HardwareAddr{0xee, 0xff, 0xff, 0xff, 0xff, 0xff}
	tunnel.arpCache.Update(neigh)

	b.Run("AllocOnly", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_ = xdp.Desc{
				Addr: 8476,
				Len:  uint32(len(frame) - tunnel.Headroom),
			}

			f := make([]byte, len(frame))
			copy(f, frame)
		}
	})

	b.Run("AllocPlusRewrite", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			desc := xdp.Desc{
				Addr: 8476,
				Len:  uint32(len(frame) - tunnel.Headroom),
			}

			f := make([]byte, len(frame))
			copy(f, frame)

			tunnel.handleIP(&desc, f, &ipMap)
			tunnel.stats.TxFrames++ // for fast checksum calculations to work
		}
	})
}

func BenchmarkIPv6TunnelRewriteShortPacket(b *testing.B) {
	testFrame := smallTcpPacket()
	frame := append([]byte{}, testFrame.OriginalFrame...)

	tunnel := Tunnel{
		Headroom:   fouHeadroom,
		sourcePort: testFrame.TunnelSourcePort,
		link: &netlink.Dummy{
			LinkAttrs: netlink.LinkAttrs{
				HardwareAddr: testFrame.OriginalFrame[fouHeadroom : fouHeadroom+6],
			},
		},
		linkMTU:  1500,
		arpCache: &arp.Cache{},
		ctx:      context.Background(),
	}

	neigh := netlink.Neigh{}
	neigh.LinkIndex = 0
	neigh.Family = unix.AF_INET
	neigh.State = unix.NUD_REACHABLE
	neigh.Type = netlink.NDA_DST
	for _, v := range testFrame.IPMap {
		neigh.IP = v.TunnelDest.AsSlice()
	}
	neigh.HardwareAddr = append([]byte{}, testFrame.TunneledFrame[:6]...)
	tunnel.arpCache.Update(neigh)

	f := make([]byte, len(frame))
	for i := 0; i < b.N; i++ {
		desc := xdp.Desc{
			Addr: 33072,
			Len:  uint32(len(frame) - tunnel.Headroom),
		}
		copy(f, frame)
		tunnel.handleIP(&desc, f, &testFrame.IPMap)
		tunnel.stats.TxFrames++ // for fast checksum calculations to work
	}
}

func BenchmarkIPv6TunnelRewriteLargePacket(b *testing.B) {
	testFrame := largeTcpPacket()
	frame := append([]byte{}, testFrame.OriginalFrame...)

	tunnel := Tunnel{
		Headroom:   fouHeadroom,
		sourcePort: testFrame.TunnelSourcePort,
		link: &netlink.Dummy{
			LinkAttrs: netlink.LinkAttrs{
				HardwareAddr: testFrame.OriginalFrame[fouHeadroom : fouHeadroom+6],
			},
		},
		linkMTU:  1500,
		arpCache: &arp.Cache{},
		ctx:      context.Background(),
	}

	neigh := netlink.Neigh{}
	neigh.LinkIndex = 0
	neigh.Family = unix.AF_INET
	neigh.State = unix.NUD_REACHABLE
	neigh.Type = netlink.NDA_DST
	for _, v := range testFrame.IPMap {
		neigh.IP = v.TunnelDest.AsSlice()
	}
	neigh.HardwareAddr = append([]byte{}, testFrame.TunneledFrame[:6]...)
	tunnel.arpCache.Update(neigh)

	f := make([]byte, len(frame))
	for i := 0; i < b.N; i++ {
		desc := xdp.Desc{
			Addr: 33072,
			Len:  uint32(len(frame) - tunnel.Headroom),
		}
		copy(f, frame)
		tunnel.handleIP(&desc, f, &testFrame.IPMap)
		tunnel.stats.TxFrames++ // for fast checksum calculations to work
	}
}
